##### 1.析构函数前加上virtual的原因
        析构函数前加上virtual的原因是为了防止内存泄漏，基类的析构函数加了virtual就可以动态绑定派生类的析构函数，这样的话，在执行
    多态后删除其对象，就可以在删除对象的时候执行派生类的析构函数了（当然执行基类的析构函数是一定会的），否则不会执行派生类的析构函数。  
    
##### 2.C++函数前后加const的区别 

    函数前加const：普通函数或成员函数（非静态成员函数）前均可加const修饰，表示函数的返回值为const，不可修改。
    格式为：  
        const returnType functionName(param list)    
    
    函数后加const：只有类的非静态成员函数后可以加const修饰，表示该类的this指针为const类型，不能改变类的成员变量的值，即成员变
    量为read only，任何改变成员变量的行为均为非法，此类型的函数可成为只读成员函数，  
    格式为：  
        returnType functionName(param list) const    
 
##### 3.菱形继承 
    概念：A作为基类，B和C都继承于A，最后一个类D又继承于B和C，这样形式的继承称为菱形继承。
    缺点：
      (1)数据冗余：在D中会保存两份A的内容。
      (2)访问不明确(二义性)：因为D不知道是以B为中介去访问A还是以C为中介去访问A，因此在访问某些成员的时候会发生二义性。
    解决方法：通过虚继承来解决菱形继承的缺点。

##### 4.C和C++之间结构体的区别
    (1)C中不允许空结构体，C++中可以，还会给空结构体1字节的空间
    (2)C++中定义结构体变量不需要加struct
    (3)在C++中，结构体中可以声明定义函数，C中只能存放函数指针
    (4)C++中成员函数中可以直接访问本结构体成员，变量不需传入，C中函数访问结构体成员必须传入结构体变量或结构体指针

##### 5.C++中struct和class的区别是什么？
        C++为了兼容C，C++中的struct继续和C中一样使用，另外C++中的struct也可以定义类，与struct不同的是，class定义的类成员默认访
    问是(private)私有的，struct定义的类成员默认访问是(public)共有的。

##### 6.this指针的特性
        (1)this指针的类型：类的类型* const 
        (2)只能在“成员函数”的内部使用
        (3)this指针本质上其实是一个成员函数的形参(只是隐藏起来了)，在对象调用成员函数时，将对象地址作为实参传递给this形参。
    所以对象中不存储this指针
        (4)this指针是成员函数第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递，除构造函数外每一个
    成员函数的第一个形参都隐藏的this指针
        (5)this指针存放在成员函数的栈里，是一个函数的形参，成员函数调用结束就释放了
        (6)this指针在成员函数的开始执行前构造，在成员函数的执行结束后清除
        (7)this指针可以为空，空的this也可以调用成员函数，但不能调用操作成员变量的函数。因为对象的地址不可能为空，所以空的this
    指针没有指向实例化的对象，也就没有实例化的成员变量，所以不能访问成员变量或者操作成员变量的函数

##### 7.缺省(默认)构造函数
    在C++的一个类中，如果构造函数没有参数，或者构造函数的所有参数都有默认值，就可以称其为缺省(默认)构造函数。一个类中，只能有一个缺省(默认)构造函数。  

##### 8.为什么C++中重载流操作符要用友元函数
        在实际操作中，流操作符左侧必须为cin或cout，即istream或ostream类，不是我们所能修改的类，这导致我们不能使用成员函数重载，只能
    使用类外的普通函数重载。由于我们将类内部的私有成员进行输入和输出，所以重载函数必须有对内部成员访问的权限，这导致我们不能使用普通的
    函数重载，只能使用友元函数重载。

##### 9.new、delete、malloc、free关系
        malloc和free是C/C++语言的标准库函数，new/delete是C++的运算符。它们都可用于申请/释放内存。对于非内部数据类型的对象而言，
    光用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于mallc/free
    是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完
    成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。
    共同点是：
        都是从堆上申请空间，并且需要用户手动释放。
    不同点是：
        1.malloc和free是函数，new和delete是操作符
        2.malloc申请的空间不会初始化，new可以初始化
        3.malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可
        4.malloc的返回值为void*，在使用时必须强转，new不需要，因为new后跟的是空间的类型、
        5.malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常
        6.申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，
    delete在释放空间前会调用析构函数完成空间中资源的清理
        7.new/delete比malloc/free的效率稍微低点，因为new/delete的底层封装了malloc/free
    
##### 10.delete与delete[]的区别
    delete只会调用一次析构函数，而delete[]会为每一个成员调用析构函数。
  
    MemTest *mTest1 = new MemTest[10];
    MemTest *mTest2 = new MenTest;
    Int *pInt1 = new int[10];
    Int *pInt2 = new int;
  
    delete[]pInt1;   //-1-
    delete[]pInt2;   //-2-
    delete[]mTest1;  //-3-
    delete[]mTest2;  //-4-
  
        在-4-处报错，这就说明：对于内部简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]不
    能互用。简单来说，用new分配的内存用delete删除；用new[]分配的内存用delete[]删除。

##### 11.将“引用”作为函数返回值类型的格式、好处和需要遵守的规则
    格式：类型标识符 &函数名（形参列表及类型说明）{//函数体}
    好处：在内存中不产生被返回值的副本，正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，
    相应的引用也会失效，产生runtime error
    注意：
       (1)不能返回局部变量的引用，主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了“无所指”的引用，程序进入未知状态
       (2)不能返回函数内部new分配的内存的引用，虽然不存在局部变量的被动销毁问题，可对于这种情况，又面临其它尴尬局面。例如，被函数
    返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间就无法释放，造成memory leak。
       (3)可以返回类成员的引用，但最好是const。主要原因是当对象的属性是与某种业务规则相关联的时候，其赋值常常与某些其它属性或者对
    象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用，那么对该属性的单纯赋值就会破
    坏业务规则的完整性。
      (4)流操作符重载返回值申明为引用的作用：流操作符<<和>>，这两个操作符常常希望被连续使用，例如：cout << "hello" << endl;
    因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。  
      (5)在另外的一些操作符中，却千万不能返回引用：+-×/四则运算符。它们不能返回引用，主要原因是这四个操作符没有side effect，因
    此，它们必须构造一个对象作为返回值。

##### 12.指针和引用的区别
    (1)指针有自己的一块空间，而引用只是一个别名。
    (2)使用sizeof看一个指针的大小为4字节(32位，如果是64位的话指针为8字节)，而引用则是被引用对象的大小。
    (3)指针可以被初始化位NULL，而引用必须被初始化且必须是一个已有对象的引用。
    (4)指针在使用中可以指向其他对象，但是引用只能是一个对象的引用，不能被改变。
    (5)如果返回动态分配内存的对象或者内存，必须使用指针，引用可能引起内存泄露。
  
##### 13.请设计一个类，该类只能在堆上创建
    (1)将构造函数私有化，拷贝构造声明成私有，防止别人调用拷贝在栈上生成对象
    (2)提供一个静态成员函数，在该静态成员函数中完成堆的创建
    class HeapOnly{
    public:
        static HeapOnly* CreateObject(){
            return new HeapOnly;
        }
      
    private:
        HeapOnly(){}
      
        HeapOnly(const HeapOnly&);
    }
    
##### 14.请设计一个类，该类只能在栈上创建
    只能在栈上创建对象，因此只要将new的功能屏蔽掉即可
    class StackOnly{
    public:
        StackOnly(){}
  
    private:
        void *operator new(size_t size);
        void operator delete(void *p);
    }

##### 15.auto\auto&\auto&&的区别
    for(auto i : c)
    一般用for(auto i : c)就是一个正常的拷贝，如果是一个类的话，会调用复制构造函数。
    如果遍历的是基本类型的话，可以这么用，如果是类的话，开销比较大，不推荐。
    vector<int> c = {1, 3, 5, 7, 9};
    for (auto i : c)
      cout << i << ' ';       //输出1,3,5,7,9


    for(auto &i : c)与for(const auto &i : c)
    这个就是i是c的引用，开销小，不会调用复制构造函数，如果不想改变原来的值得花，可以用for(const auto &i : c)，
    如果想要改变的话，用for(auto &i : c)
    vector<int> c = {1, 3, 5, 7, 9};
    for (auto &i : c)  
        i *= 10;      
    for (auto i : c)
        cout << i << ' ';   //输出10,30,50,70,90


    for(auto &&i : c) 
    重头戏在这个地方啦，如果c为一个proxy iterators的话，这方面的典型例子就是vector< bool>
    有一个地方需要注意：
    vector<bool> c{ false, true, false, true, false };
    for (auto i : c)
        cout << i << " ";            //输出0 1 0 1 0
    cout << endl;
    for (auto i : c){
        i = !i;
    }
    for (auto i : c)
       cout << i << " ";            //输出1 0 1 0 1
    cout << endl;

    如果对于vector< bool>用for(auto i : c)，对i做改变，也会影响到c。 
    而对于vector< bool>用for(auto &i : c)在g++上会报错 
    所以此时需要用右值引用for(auto &&i : c)
    vector<bool> c{ false, true, false, true, false };
    for (auto &&i : c){
        i = !i;
    }

    而&&还可以用于非proxy iterators的情况，所以一般情况下，如果要修改遍历的值，都要用
    for (auto &&i : c)
    如果不修改的话，要用
    for (const auto &i : c)
    因为常量引用可以绑定到一个临时值上面，用来延长临时值得生命周期 

##### 16.为什么需要智能指针
    为了更好的解决以下两个问题所以出现了智能指针  
    1.当我们malloc出来的内存没有去释放时就会出现问题，就会存在内存泄漏问题。  
    2.异常安全问题。如果在malloc和free之间如果存在抛出异常，那么还是有内存泄漏。这种问题就叫异常安全。  
    
##### 17.C++四种类型转换
```
C++四种类型转换：static_cast、dynamic_cast、const_cast、reinterpret_cast。

为什么不使用C的强制转换？
C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。

static_cast：可以实现C++中内置基本数据类型之间的相互转换。它主要有如下几种用法：
用于类层次结构中基类和派生类之间指针或引用的转换，进行上行转换（把派生类的指针或引用转换成基类表示）是安全的，进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的；
    用于基本数据类型之间的转换，如把int转换成char。这种转换的安全也要开发人员来保证；
    把空指针转换成目标类型的空指针；
    把任何类型的表达式转换为void类型。
注意：static_cast不能转换掉expression的const、volitale或者__unaligned属性。

如果涉及到类的话，static_cast只能在有相互联系的类型中进行相互转换，不一定包含虚函数。

const_cast：可以强制去掉const这种不能被修改的常数特性，但需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。通常用于去除const类型返回值的常量性。

为什么要设定为去除指向常数对象的指针或引用呢？

因为，如果可以将变量的常量性去除，那么就和const的常量意思相悖了，这是很可怕的。而如果是指向该常量的指针，尽管该指针指向的是常量，但是去除它的常量性，也是可以理解的。但是，这样就出现了可能指向同一块内存地址的指针和这块内存地址的常量值不同的情况（解释可以看下面的参考文献）。

reinterpret_cast：主要有三种强制转换用途，改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型。也就是说，它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针。在使用reinterpret_cast强制转换过程仅仅只是比特位的拷贝，因此在使用过程中需要特别谨慎！

dynamic_cast：其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。

不能用于内置的基本数据类型的强制转换；
dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL；
使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过；
在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。
向上转换，即为子类指针指向父类指针（一般不会出问题）；

向下转换，即将父类指针转化子类指针。向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。

为什么dynamic_cast基类中必须要有虚函数？

dynamic_cast依赖于RTTI信息。RTTI(Run Time Type Identification)即通过运行时类型识别，程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型。许多编译器都是通过vtable找到对象的RTTI信息的，这也就意味着，如果基类没有虚方法，也就无法判断一个基类指针变量所指对象的真实类型。

dynamic_cast 主要用于执行“安全的向下转型（safe downcasting）”，要实现dynamic_cast，编译器会在每个含有虚函数的类的虚函数表的前四个字节存放一个指向_RTTICompleteObjectLocator结构的指针，当然还要额外空间存放_RTTICompleteObjectLocator及其相关结构的数据。
```
